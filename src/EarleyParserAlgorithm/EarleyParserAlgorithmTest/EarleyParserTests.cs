using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using EarleyParserAlgorithm;

namespace EarleyParserAlgorithmTest
{
    [TestClass]
    public class EarleyParserTests
    {
        [TestMethod]
        public void Test_SingleTerminalAccepted()
        {
            // Grammar: S -> "a"
            Grammar grammar = new Grammar("S");
            Rule rule = new Rule("S", new string[] { "a" });
            grammar.AddRule(rule);
            EarleyParser parser = new EarleyParser(grammar);
            List<string> tokens = new List<string>();
            tokens.Add("a");
            bool result = parser.Parse(tokens);
            Assert.IsTrue(result, "The parser should accept a single 'a' token.");
            // Test with an invalid terminal.
            tokens = new List<string>();
            tokens.Add("b");
            result = parser.Parse(tokens);
            Assert.IsFalse(result, "The parser should reject token 'b'.");
        }

        [TestMethod]
        public void Test_EpsilonProduction()
        {
            // Grammar: S -> Îµ   (empty production)
            Grammar grammar = new Grammar("S");
            Rule rule = new Rule("S", new string[] { });
            grammar.AddRule(rule);
            EarleyParser parser = new EarleyParser(grammar);
            // Accept empty input.
            List<string> tokens = new List<string>();
            bool result = parser.Parse(tokens);
            Assert.IsTrue(result, "The parser should accept empty input with epsilon production.");
            // Non-empty input should be rejected.
            tokens.Add("a");
            result = parser.Parse(tokens);
            Assert.IsFalse(result, "The parser should reject non-empty input when only epsilon production exists.");
        }

        [TestMethod]
        public void Test_LongSequence()
        {
            // Grammar: S -> "a" S | "a"
            Grammar grammar = new Grammar("S");
            Rule rule1 = new Rule("S", new string[] { "a", "S" });
            Rule rule2 = new Rule("S", new string[] { "a" });
            grammar.AddRule(rule1);
            grammar.AddRule(rule2);
            EarleyParser parser = new EarleyParser(grammar);
            // Generate a long sequence of "a"s.
            List<string> tokens = new List<string>();
            for (int i = 0; i < 100; i++)
            {
                tokens.Add("a");
            }

            bool result = parser.Parse(tokens);
            Assert.IsTrue(result, "The parser should accept a long sequence of 'a's generated by the recursive grammar.");
            // Introduce an invalid token into the sequence.
            tokens[50] = "b";
            result = parser.Parse(tokens);
            Assert.IsFalse(result, "The parser should reject the sequence if one token is invalid.");
        }
    }
}